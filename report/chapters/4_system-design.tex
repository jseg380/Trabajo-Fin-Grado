\chapter{System design and architecture}

This chapter provides a detailed exposition of the architectural design and technical framework for the \textit{AlDiaCAR} application. The design is fundamentally guided by the project's core objectives as defined in the preceding chapters: to deliver a cross-platform, scalable, and maintainable software solution that empowers households to manage and optimize their personal vehicle usage with a primary focus on enhancing sustainability and reducing operational friction.

\textgap

The following sections will deconstruct the system from a high-level perspective down to its constituent components. We will begin by outlining the overarching client-server architecture, providing a rationale for this fundamental design choice. Subsequently, we will conduct a deep dive into the specific architectural patterns employed within both the frontend and backend, justifying the decisions made to balance complexity, performance, and developer ergonomics. The chapter will also thoroughly define the data model that enables the system's collaborative features, detail the communication protocols and security measures governing the data flow, and provide a comprehensive justification for the selected technology stack. This architectural blueprint serves as the technical foundation upon which the application's features, detailed in Chapter 5, are built.

\section{High-level architecture: A client-server model}

The system is architected following a classic, robust client-server model, a paradigm in which a client requests resources and a server provides them, forming the basis of modern distributed applications \cite{Tanenbaum2011ComputerNetworks}. This approach was chosen for its clear separation of concerns, which effectively decouples the presentation layer (the user interface) from the application's core business logic and data persistence layers. This separation is paramount for achieving several key non-functional requirements. It enhances security by abstracting the database behind a controlled Application Programming Interface (API), improves scalability by allowing the client and server to be scaled independently, and provides strategic flexibility for future development, such as the creation of a web-based client or third-party integrations, without necessitating any modifications to the backend infrastructure. This decoupling is achieved through the use of well-defined APIs, which act as stable architectural boundaries that allow each component to evolve independently \cite{Martin2017CleanArchitecture}.

\textgap

The system is composed of four primary, logically distinct components:
\begin{itemize}
    \item \textbf{Frontend Client:} A cross-platform mobile application that serves as the sole point of interaction for the end-user. It is responsible for rendering the user interface, capturing user input, managing client-side state, and handling all communication with the backend server. The use of React Native and the Expo framework enables a single codebase to target both iOS and Android platforms.
    \textgap
    \item \textbf{Backend Server:} The central nervous system of the application. Implemented as a Node.js application using the Express.js framework, the backend serves as the authoritative hub for all operations. Its responsibilities include handling business logic, processing data, managing user authentication and authorization, and serving as the exclusive intermediary for all database interactions.
    \textgap
    \item \textbf{Database:} A MongoDB NoSQL database instance is utilized for all persistent data storage. This includes household profiles, user accounts, detailed vehicle specifications, maintenance schedules, and trip logs. Its flexible, document-oriented nature provides the agility required for an evolving data model.
    \textgap
    \item \textbf{Mock API (Development Environment):} To facilitate robust and isolated development, a secondary Node.js server is included in the development environment. This server simulates a third-party API for retrieving vehicle specifications (e.g., emission factors), allowing the core application to be developed and tested with deterministic data without reliance on external services.
\end{itemize}

\textgap

Figure \ref{fig:high-level-arch} provides a visual representation of this architecture, illustrating the primary components and the standardized data flow protocols that connect them within the development environment.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=2.5cm and 3cm
    ]
    % Components
    \node[user] (user) {User};
    \node[comp, right=of user] (frontend) {\textbf{Frontend Client} \\ React Native (Expo) \\ \textit{Presentation Layer}};

    % Backend server, placed below frontend
    \node[comp, below=of frontend, yshift=-0.5cm, xshift=3.5cm] (backend) {\textbf{Backend API} \\ Node.js / Express.js \\ \textit{Business Logic Layer}};

    % Mock API server
    \node[comp, left=of backend, xshift=1cm] (mockapi) {\textbf{Mock Car API} \\ Node.js \\ \textit{Development/Test Stub}};

    % Database
    \node[db, below=of backend, yshift=1cm] (db) {MongoDB \\ \textit{Data Persistence Layer}};

    % Docker environment container
    \begin{pgfonlayer}{background}
        \node[env, label=above:{\color{gray}\small Docker Environment}, fit=(backend) (db) (mockapi), inner sep=0.5cm] (dockerenv) {};
    \end{pgfonlayer}

    % Arrows
    \draw[arrow] (user.east) -- (frontend.west);
    \draw[arrow] (frontend.south east) -- (backend.north) node[midway, right, xshift=0.1cm, align=center] {\textbf{REST API} \\ (HTTPS/JSON)};
    \draw[arrow] (backend.south) -- (db.north) node[midway, left] {Mongoose ODM};
    \draw[arrow, dashed] (frontend.south west) -- (mockapi.north) node[midway, left, align=center] {Mock API Call \\ (Dev only)};

    \end{tikzpicture}
    \caption{High-level system architecture, illustrating the separation of layers and data flow.}
    \label{fig:high-level-arch}
\end{figure}

\section{Backend architecture: A Model-View-Controller approach}

The backend is architected as a monolithic RESTful API adhering to the Model-View-Controller (MVC) design pattern, a well-established architectural pattern for separating application concerns and improving modularity, as influenced by the principles of object-oriented design \cite{Gamma1995DesignPatterns}. This classical pattern was selected for its proven efficacy in organizing server-side applications, promoting a clear separation of concerns that directly maps to the project's directory structure. This organizational clarity enhances maintainability and simplifies development.

\textgap

The request-response lifecycle within the backend follows a well-defined path, as illustrated in the sequence diagram in Figure \ref{fig:backend-lifecycle}. An incoming HTTP request from the client is first received by the Express.js router. The router identifies the appropriate endpoint and forwards the request through a chain of middleware functions, primarily for authentication. Upon successful validation, the request is handed to the designated controller function, which contains the core business logic. The controller interacts with the Mongoose model to perform necessary database operations (Create, Read, Update, Delete - CRUD). Finally, the controller formats the response and sends it back to the client.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/backend-lifecycle-diagram.png}
    \caption{Sequence diagram of the backend request-response lifecycle.}
    \label{fig:backend-lifecycle}
\end{figure}

\subsection{Backend components}
\begin{itemize}
    \item \textbf{Routes (`/routes`):} This layer defines the API's endpoints. It maps specific HTTP methods (GET, POST, PUT, DELETE) and URL paths to their corresponding controller functions. The design employs dedicated route files for each logical resource (e.g., \texttt{authRoutes.js}, \texttt{vehicleRoutes.js}, \texttt{householdRoutes.js}), promoting modularity.
    \textgap
    \item \textbf{Controllers (`/controllers`):} Controllers form the heart of the business logic. Each function within a controller is responsible for handling a specific request, orchestrating the necessary operations, and formulating the final response. In the current architecture, controllers directly interact with the Mongoose models to execute data operations and contain all business-specific logic, such as calculating maintenance alerts or processing vehicle recommendations.
    \textgap
    \item \textbf{Models (`/models`):} This layer defines the data structures (schemas) for the application's entities using Mongoose, an Object Data Modeling (ODM) library for MongoDB. The primary models are \texttt{Household.js}, \texttt{User.js}, \texttt{Vehicle.js}, and \texttt{Trip.js}. These models provide a high-level abstraction for all interactions with the database.
    \textgap
    \item \textbf{Middleware (`/middleware`):} Middleware functions are executed between the router and the controller. They are primarily used for cross-cutting concerns. The most critical middleware, \texttt{authMiddleware.js}, is responsible for protecting routes by extracting and verifying the user's JSON Web Token (JWT), ensuring that only authenticated users can access protected resources.
\end{itemize}

\subsection{Architectural Decision: Controller-Centric Business Logic}
A deliberate architectural decision was made to embed all business logic directly within the controller layer, rather than abstracting it into a separate "Service Layer." For the current scope and complexity of the project, this approach offers the benefit of simplicity and reduces developmental overhead. It allows for rapid iteration on the core functionalities of the prototype. However, it is recognized that as an application scales, this approach can lead to "fat controllers" and code duplication. Future iterations of the system would likely require refactoring to introduce a dedicated service layer to encapsulate reusable business logic, thereby improving modularity and testability.

\section{Frontend Architecture: A Hybrid State Management Strategy}

The frontend client, built with React Native and Expo, employs a pragmatic hybrid state management strategy. This approach avoids the dogmatic application of a single pattern, instead choosing the most appropriate tool for each type of state, thereby optimizing for both developer experience and application performance.

\subsection{Global State Management via React Context}
For state that is truly global and required across many disparate parts of the application, the React Context API is employed. The primary use case for this is user authentication. The \texttt{AuthContext} provides the entire component tree with access to the current user's data, authentication status, and functions for logging in and out. This approach is ideal for such cross-cutting concerns because it is lightweight, built directly into the React library, and avoids the complexity of larger, third-party state management libraries.

\subsection{Screen-Level State Management (MVVM-like Pattern)}
For state that is local to a specific screen, the architecture follows a pattern that is conceptually aligned with Model-View-ViewModel (MVVM), where each screen manages its own state and logic, a common approach in modern client-side applications for achieving a clean separation of the view from its underlying model \cite{Garg2013ComparingPatterns}. Each screen component is responsible for managing its own state (e.g., list of vehicles, loading status) and data-fetching logic using React's built-in hooks. This encapsulation prevents the global state from becoming a bottleneck, improves performance by preventing unnecessary re-renders, and makes components easier to test in isolation. This approach aligns with the principles of modern, declarative UI development prevalent in the React Native ecosystem \cite{Djirdeh2018FullstackReactNative}.

\section{Data Architecture and Modeling}

The design of the data model is critical to supporting the application's core collaborative features.

\subsection{Rationale for a NoSQL Database (MongoDB)}
A NoSQL database, specifically MongoDB, was chosen over a traditional relational database for its flexible data schema. The domain of vehicle management involves entities with diverse attributes; for example, an electric vehicle's data profile differs significantly from that of a diesel vehicle. A NoSQL document-based model allows for these variations to exist within the same collection without requiring complex schema migrations. This approach aligns with the principles of aggregate-oriented databases, which prioritize scalability and development flexibility \cite{Sadalage2012NoSQLDistilled}.

\subsection{Core Collections and Collaborative Relationships}
The data model is architected around the central concept of the "household," as shown in Figure \ref{fig:data-model-detailed}. This design directly reflects the problem statement and enables all multi-user functionalities.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=2cm and 1.5cm,
        entity/.style={
            rectangle, rounded corners, draw=black, very thick,
            minimum width=3.5cm, minimum height=2cm, align=left,
            text width=4.5cm, fill=blue!10, drop shadow
        },
        arrow/.style={-{Latex[length=3mm]}, very thick}
    ]

    % Entities
    \node[entity] (household) {\textbf{Household Collection} \\ \texttt{\_id: ObjectId (PK)} \\ \texttt{name: String} \\ \texttt{joinCode: String (unique)} \\ \texttt{owner: ObjectId (FK -> User)}};
    \node[entity, below left=of household, xshift=0.5cm] (user) {\textbf{User Collection} \\ \texttt{\_id: ObjectId (PK)} \\ \texttt{name: String} \\ \texttt{household: ObjectId (FK -> Household)}};
    \node[entity, below right=of household, xshift=-2cm, yshift=0.3cm] (vehicle) {\textbf{Vehicle Collection} \\ \texttt{\_id: ObjectId (PK)} \\ \texttt{owner: ObjectId (FK -> User)} \\ \texttt{make: String} \\ \texttt{model: String}};

    % Relationships
    \draw[arrow] (household.south west) -- (user.north) node[midway, left, align=center, xshift=-0.8cm] {1..n \\ has member};
    \draw[arrow] (user.east) -- (vehicle.west) node[midway, above, align=center] {1..n \\ owns};
    \path (household.south east) edge[arrow, dashed] node[midway, right, text width=2cm, align=center, xshift=0.8cm] {contains (via owner)} (vehicle.north);

    \end{tikzpicture}
    \caption{Detailed data model illustrating the central role of the Household collection and its relationships with users and vehicles.}
    \label{fig:data-model-detailed}
\end{figure}

The primary collections and their relationships are as follows:
\begin{itemize}
    \item \textbf{Households:} This is the central collection that groups users and their shared assets. Each household has a unique, randomly generated `joinCode` to facilitate a simple and secure invitation mechanism.
    \item \textbf{Users:} Each user document is linked to a single `Household` via a reference ID. When a new user registers, a personal household is created for them by default. They can then join other households or invite others to theirs.
    \item \textbf{Vehicles:} Each vehicle is owned by a single user. A vehicle's association with a household is therefore derived implicitly through its owner's membership in that household. This enables authorization logic where any member of a household can view and interact with any vehicle owned by another member of the same household.
\end{itemize}
A comprehensive definition of all Mongoose data schemas is provided in Appendix B.

\section{API design and security protocols}
The Application Programming Interface (API) is the critical boundary between the client and server, and its design is governed by principles of standardization and security.

\subsection{API design: RESTful principles}
The API is designed following REST (Representational State Transfer) principles, adhering to the constraints of statelessness, resource-based addressing, and a uniform interface as defined in the foundational architectural style \cite{Fielding2000REST}. It uses standard HTTP methods (GET, POST, PUT, DELETE) for operations and leverages URL paths to identify resources (e.g., \texttt{/api/vehicles}). This adherence to web standards makes the API predictable and easy to consume. A complete specification of all API endpoints is available in Appendix A.

\subsection{Authentication and authorization}
The system employs a robust, token-based security model.
\begin{itemize}
    \item \textbf{Authentication:} User authentication is managed via JSON Web Tokens (JWTs). Upon successful login, the backend server generates a signed JWT and sends it to the client in a secure, \textbf{HTTP-Only} cookie. The HTTP-Only flag is a crucial security measure that prevents the token from being accessed by client-side JavaScript, mitigating the risk of Cross-Site Scripting (XSS) attacks.
    \textgap
    \item \textbf{Authorization:} The system's authorization strategy is \textbf{Household-Based Access Control}. Once a user is authenticated, the middleware performs a second check for any request that attempts to access a resource (like a vehicle). The logic verifies that the requesting user is a member of the same household as the resource's owner. If they are not, the request is rejected with a `403 Forbidden` status. This model ensures that users can only interact with vehicles within their own household group.
\end{itemize}

\section{Technology stack justification}

The selection of each technology was the result of a deliberate evaluation of the project's requirements.
\begin{itemize}
    \item \textbf{React Native (with Expo):} Chosen for its primary benefit of cross-platform development, allowing a single codebase to generate native applications for both iOS and Android. This drastically reduces development time.
    \newline\textit{Considered Alternative: Flutter.} Flutter was a strong contender but was ultimately not selected due to the project's reliance on the vast JavaScript/React ecosystem and the desire for language synergy with the backend.
    \textgap
    \item \textbf{Node.js with Express.js:} Selected for the backend due to its non-blocking, event-driven architecture, which provides excellent performance for an API server. Its use of JavaScript creates a seamless, full-stack development experience.
    \newline\textit{Considered Alternative: Python with Django/Flask.} This stack was passed over to maintain language consistency across the entire project.
    \textgap
    \item \textbf{MongoDB:} As previously detailed, MongoDB was chosen for its flexible document-based schema, highly suited to the evolving data structures of vehicle profiles.
    \newline\textit{Considered Alternative: PostgreSQL.} A relational database was considered for its data integrity features, but the need for schema flexibility was deemed more critical for this project.
    \textgap
    \item \textbf{Docker:} Docker and Docker Compose are utilized to containerize the backend services. This practice is a key enabler of modern Continuous Delivery pipelines, as it eliminates environmental discrepancies and simplifies the deployment process \cite{Humble2010ContinuousDelivery}.
\end{itemize}

\section{Architectural considerations for external integrations}

While the current proof-of-concept uses simplified, hardcoded data for features like ZBE detection, the Zenith Release vision requires integration with several third-party services. To manage these future integrations without creating tight coupling, the backend architecture will employ the \textbf{Adapter Pattern}. For each external service (e.g., ZBE data, fuel prices, mapping), a dedicated "adapter" module will be created. This module will act as an intermediary, translating the application's internal requests into the specific format required by the external API and translating the response back into a standardized format. This abstraction ensures that if a data provider changes in the future, only the corresponding adapter module needs to be rewritten, leaving the core business logic of the application untouched.
