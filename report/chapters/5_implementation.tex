\chapter{Implementation details}

This chapter transitions from the abstract architectural design of Chapter 4 to the concrete technical implementation of the \textit{AlDiaCAR} system. The objective is to provide a detailed walkthrough of the project's source code, explaining the organizational structure, key software modules, and the programming patterns employed to bring the conceptual design to life. This chapter serves as a bridge between the system's architecture and its validation, detailing not only *what* was built but also the quality assurance strategy designed to verify its correctness and robustness.

\section{Project structure overview}

The project is organized as a monorepo, a single repository containing all the code for the system. This approach simplifies dependency management and streamlines development across the different parts of the application, which is particularly advantageous for a full-stack project with tightly coupled frontend and backend components. The high-level directory structure, which promotes a clear separation of concerns, is shown in Figure \ref{fig:dirtree}.

\begin{figure}[h!]
\dirtree{%
.1 .
.2 config/ \textit{(Docker service configurations)}.
.3 mongo-express-config.js.
.2 docker/ \textit{(Local environment definition)}.
.3 docker-compose.yaml.
.2 src/ \textit{(Main source code)}.
.3 backend/ \textit{(Node.js REST API)}.
.4 controllers/.
.4 middleware/.
.4 models/.
.4 routes/.
.4 server.js.
.3 frontend/ \textit{(React Native mobile app)}.
.4 app/ \textit{(Expo file-based routes)}.
.4 components/.
.4 context/.
.4 localization/.
.2 tests/ \textit{(Automated tests)}.
.3 backend/ \textit{(Jest tests)}.
.3 frontend/ \textit{(Playwright E2E tests)}.
.2 package.json \textit{(Root monorepo scripts)}.
}
\caption{High-level project directory structure.}
\label{fig:dirtree}
\end{figure}

The \texttt{src} directory cleanly separates the \texttt{backend} and \texttt{frontend} codebases. The \texttt{docker} directory contains the Docker Compose configuration, ensuring a reproducible development environment for all services. Finally, the \texttt{tests} directory houses the automated quality assurance framework, with distinct subdirectories for backend and frontend testing.

\section{Backend implementation (Node.js)}

The backend is a RESTful API built with Node.js and the Express.js framework. It is the authoritative core of the system, responsible for all business logic, data persistence, and security enforcement.

\subsection{Data models and persistence (Mongoose)}
Data schemas are defined in the \texttt{src/backend/models/} directory using Mongoose, an Object Data Modeling (ODM) library that provides a robust abstraction layer for interacting with the MongoDB database. The principal models implemented are \texttt{Household.js}, \texttt{User.js}, \texttt{Vehicle.js}, and \texttt{Trip.js}.

\textgap

The collaborative nature of the application is enabled by the \texttt{Household} model. A key feature of this schema is the automatic generation of a unique, human-readable `joinCode` upon creation, facilitated by the `nanoid` library. This code serves as a simple and secure mechanism for users to join existing households. A snippet of this implementation is shown below.

\begin{lstlisting}[language=JavaScript, caption={Join Code Generation in \texttt{models/Household.js}}]
import mongoose from 'mongoose';
import { customAlphabet } from 'nanoid';

// Using a dictionary-based alphabet for memorable codes
const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
const nanoid = customAlphabet(alphabet, 8);

const HouseholdSchema = new mongoose.Schema({
  // ... other fields
  joinCode: {
    type: String,
    required: true,
    unique: true,
    // Automatically generate code on creation
    default: () => nanoid(),
  },
  // ... other fields
});
\end{lstlisting}
The full, detailed Mongoose schemas for all data models are provided in Appendix B for comprehensive review.

\subsection{Controllers and business logic}
The core business logic of the application resides within the controller files in the \texttt{src/backend/controllers/} directory. These modules orchestrate the interactions between incoming API requests, the data models, and the final response sent to the client.

\textgap

A prime example of this orchestration is the user registration flow within \\\texttt{authController.js}. When a new user registers, the system not only creates a new \texttt{User} document but also atomically creates a new, personal \texttt{Household} for that user, establishing the foundational link for all collaborative features from the moment of inception.

\textgap

The logic for managing collaborative groups is encapsulated in \\\texttt{householdController.js}. The \texttt{joinHousehold} function handles the complex state changes required when a user moves from one household to another. This includes adding the user to the new household's member list, updating the user's own household reference, removing them from their previous household, and, critically, deleting the old household if the departing user was its last member. This logic, illustrated in Figure \ref{fig:join-household-flow}, ensures data integrity and prevents orphaned household documents in the database.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance = 1cm and 0.8cm,
        process/.style={
            rectangle, 
            draw, 
            fill=blue!10, 
            text width=6em, 
            align=center, 
            rounded corners, 
            minimum height=2em
        },
        decision/.style={
            diamond, 
            draw, 
            fill=green!10, 
            text width=6em, 
            align=center, 
            aspect=2
        },
        arrow/.style={
            thick,
            -{Stealth[]}
        },
        line/.style={ % For edges with labels
            draw, 
            thick,
            -{Stealth[]}
        }
    ]
        % Initial top-down flow
        \node (A) [process] {User clicks 'Join'};
        \node (B) [decision, below=of A] {Find Target Household?};
        \node (C) [decision, below=of B] {User exists in Target?};
        
        % "Yes" branch goes to the right
        \node (D) [process, right=of C] {End: Already a member};
        
        % Main flow continues down
        \node (E) [process, below=of C] {Add user to Target members};
        \node (F) [process, below=of E] {Update user's reference};
        \node (G) [process, below=of F] {Remove user from Old members};
        
        % The flow now "turns" to the right
        \node (H) [decision, right=of G] {Old Household empty?};
        
        % Final branches go above and below this new horizontal axis
        \node (I) [process, above=of H] {Delete Old Household};
        \node (J) [process, below=of H] {Save Old Household};
        \node (K) [process, right=of H] {Save all \& respond};

        % Draw arrows with labels
        \draw [arrow] (A) -- (B);
        \draw [arrow] (B) -- (C);
        \draw [line] (C) -- node[above] {Yes} (D);
        \draw [line] (C) -- node[left] {No} (E);
        \draw [arrow] (E) -- (F);
        \draw [arrow] (F) -- (G);
        \draw [arrow] (G) -- (H);
        \draw [line] (H) -- node[left] {Yes} (I);
        \draw [line] (H) -- node[left] {No} (J);
        \draw [arrow] (I) -- (K);
        \draw [arrow] (J) -- (K);
    \end{tikzpicture}
    \caption{Logical flow diagram for the `joinHousehold` controller function.}
    \label{fig:join-household-flow}
\end{figure}

\subsection{API routes and security middleware}
API endpoints are defined in the \texttt{src/backend/routes/} directory. These files map URL paths and HTTP methods to their corresponding controller functions. Security is enforced at this layer through custom middleware. The most critical of these is the \texttt{protect} function in \texttt{authMiddleware.js}, which is applied to all sensitive routes. This middleware extracts the JWT from an \texttt{HttpOnly} cookie sent with the client's request, verifies its signature against the server's secret key, and, if valid, decodes the user's ID from the token payload. This ID is then attached to the Express request object, making the authenticated user's identity securely available to all subsequent controller logic without needing to pass it in the request body.

\textgap

A complete specification of all API endpoints, including their routes, required HTTP methods, expected payloads, and required authentication level, is available in Appendix A.

\section{Frontend implementation (React Native)}

The frontend is a cross-platform mobile application developed using React Native with the Expo framework and TypeScript for static typing. It provides the user interface and manages all interactions with the backend API.

\subsection{Navigation and screen architecture}
The application's navigation is managed by Expo's file-based router. The directory structure within \texttt{src/frontend/app/} directly translates into the app's navigational routes. The main user interface is structured around a tab bar, defined in \texttt{app/(tabs)/\_layout.tsx}, which provides access to the primary sections: Home, Vehicles, Routes, and Stats.

\textgap

A key programming pattern employed across the main screens is the \\\texttt{useFocusEffect} hook from Expo Router. This hook is used to re-fetch data from the backend whenever a screen comes into focus. This ensures that the data displayed to the user is always fresh and reflects any changes made on other screens (e.g., refreshing the vehicle list after a new vehicle has been added), providing a seamless and intuitive user experience.

\subsection{State management and API communication}
The frontend employs a hybrid state management strategy.
\begin{itemize}
    \item \textbf{Global State:} Application-wide state, specifically the user's authentication status and profile information, is managed via React's Context API. The implementation in \texttt{context/AuthContext.tsx} creates a provider that wraps the entire application, making the user's identity and authentication status accessible to any component without the need for prop drilling.
    \item \textbf{Local State:} Screen-specific state, such as the list of vehicles on the vehicle management screen, is managed locally within each component using React's native \texttt{useState} and \texttt{useEffect} hooks.
\end{itemize}
All communication with the backend API is handled by the \texttt{axios} library. A global instance of axios is configured with the \texttt{withCredentials: true} option. This crucial setting instructs the library to automatically include the secure, \texttt{HttpOnly} authentication cookie with every request sent to the backend, seamlessly managing user sessions.

\section{Quality assurance and test planning}
To ensure the correctness and reliability of the implemented proof-of-concept, a multi-layered testing strategy was designed, adopting principles from the classic software testing pyramid. This strategy combines low-level unit and integration tests with high-level end-to-end tests to validate the system's functionality from different perspectives.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        pyramid/.style={
            trapezium,
            trapezium left angle=70,
            trapezium right angle=70,
            minimum height=1.5cm,
            draw, thick,
            text width=4cm,
            align=center
        },
        font=\sffamily
    ]

    \node[pyramid, text width=6cm, fill=red!20] (e2e) {End-to-End Tests \\ (Playwright)};
    \node[pyramid, text width=5cm, fill=yellow!20, above=1cm of e2e] (integration) {Integration Tests \\ (Jest + Supertest)};
    \node[pyramid, text width=4cm, fill=green!20, above=1cm of integration] (unit) {Unit Tests \\ (Jest)};
    
    \node[right=0.5cm of e2e, text width=5cm, anchor=west] {\textbf{Validates:} Full user journeys through the UI. \\ \textbf{Example:} User registers, logs in, adds a vehicle, and makes a reservation.};
    \node[right=0.5cm of integration, text width=6cm, anchor=west] {\textbf{Validates:} Interaction between backend components. \\ \textbf{Example:} API endpoint correctly calls controller, which updates the database.};
    \node[right=0.5cm of unit, text width=7cm, anchor=west] {\textbf{Validates:} Individual functions or modules in isolation. \\ \textbf{Example:} A utility function correctly formats a date string.};

    \end{tikzpicture}
    \caption{The software testing pyramid as applied to the AlDiaCAR project.}
    \label{fig:testing-pyramid}
\end{figure}

As illustrated in Figure \ref{fig:testing-pyramid}, the strategy is composed of the following layers:
\begin{itemize}
    \item \textbf{Backend testing (Jest \& Supertest):} The backend test suite, located in \texttt{tests/backend/}, uses the Jest framework. Unit tests are planned for individual utility functions and complex business logic modules in isolation. Integration tests, using the Supertest library, are designed to validate the complete request-response cycle of the API endpoints. The implemented test suite for this thesis focuses on the most critical endpoints, such as user authentication and the vehicle recommendation logic, to validate the core "vertical slice" of the application.
    \textgap
    \item \textbf{Frontend testing (Playwright):} End-to-End (E2E) tests are designed to simulate a real user's journey through the application from start to finish. The test plan for this proof-of-concept, located in \texttt{tests/frontend/}, utilizes the Playwright framework to create automated scripts for the most critical user flows: (1) successful user registration and login, (2) adding a new vehicle to a household, and (3) making a reservation for an available vehicle.
\end{itemize}
This testing strategy ensures that the most critical path of the application is validated at multiple levels of abstraction. The results of these tests are presented in Chapter 6.

\section{Development effort and cost analysis}

While this project was undertaken within an academic context, it is valuable to perform a cost analysis to estimate the resources required to develop a market-ready product based on the AlDiaCAR concept. This section provides a high-level budget estimation, breaking down the costs associated with the development of the "Thesis-Grade Beta" (the scope implemented for this project) and projecting the additional investment needed to achieve the full Zenith release.

\subsection{Methodology and assumptions}

The budget is calculated based on a team of freelance professionals based in Spain, with standard market rates for software development roles. The estimation is based on the hours required for each key phase of the project: design, development, and project management.

The following roles and hourly rates are assumed:
\begin{itemize}
\item \textbf{Project manager / Product owner:} Responsible for requirements, planning, and oversight. Rate: €50/hour.
\item \textbf{UI/UX Designer:} Responsible for visual identity, wireframing, and creating high-fidelity mockups. Rate: €35/hour.
\item \textbf{Backend developer:} Responsible for the server, API, and database architecture. Rate: €40/hour.
\item \textbf{Frontend (Mobile) developer:} Responsible for the React Native application. Rate: €40/hour.
\end{itemize}

\subsection{Estimated development costs}

Table \ref{tab:development_costs} outlines the estimated hours and costs for the development of the Thesis-Grade Beta (representing the completed Alpha and Beta phases) and the projected additional effort required to complete the Zenith release.

\begin{table}[H]
\small
\centering
\caption{Estimated development costs by phase}
\label{tab:development_costs}
\begin{tabular}{>{\raggedright\arraybackslash}p{3cm} | >{\centering\arraybackslash}p{1.5cm} >{\centering\arraybackslash}p{1.5cm} | >{\centering\arraybackslash}p{1.5cm} |  >{\centering\arraybackslash}p{1.5cm} >{\centering\arraybackslash}p{1.5cm}}
\hline
\textbf{Role} & \textbf{Hours (Beta)} & \textbf{Hours (Zenith add-on)} & \textbf{Rate (€/hr)} & \textbf{Subtotal (Beta)} & \textbf{Subtotal (Zenith add-on)} \\[2pt]
\hline
Project manager & 40 hrs & 60 hrs & €50 & €2,000 & €3,000 \\[0.9cm]
UI/UX Designer & 30 hrs & 40 hrs & €35 & €1,050 & €1,400 \\[0.9cm]
Backend developer & 120 hrs & 100 hrs & €40 & €4,800 & €4,000 \\[0.9cm]
Frontend developer & 120 hrs & 100 hrs & €40 & €4,800 & €4,000 \\[0.9cm]
\hline
\textbf{Total person-hours} & \textbf{310 hrs} & \textbf{300 hrs} & --- & --- & --- \\[2pt]
\textbf{Subtotal labor costs} & --- & --- & --- & \textbf{€12,650} & \textbf{€12,400} \\[2pt]
\hline
\multicolumn{5}{r}{\textbf{Projected total for Zenith release:}} & \textbf{€25,050} \\
\hline
\end{tabular}
\end{table}

The development of the Thesis-Grade Beta, which includes the critical household data model, the reservation system, and the full multi-factor recommendation engine, is estimated to require approximately 310 person-hours, resulting in a cost of €12,650.

\textgap

To complete the Zenith release, which would involve integrating live third-party APIs, building the full graphical analytics dashboard, and implementing the collaborative gamification layer, an additional 300 person-hours are projected. This would represent a further investment of €12,400, bringing the total estimated development cost for a market-ready Zenith version to €25,050.

\subsection{Other associated costs}

Beyond direct development labor, a production-grade application would incur other initial and ongoing costs. These are summarized in Table \ref{tab:other_costs}.

\begin{table}[H]
\normalsize
\centering
\caption{Other costs annual estimation}
\label{tab:other_costs}
\begin{tabular}{l|p{6.6cm}|r}
\hline
\textbf{Category} & \textbf{Description} & \textbf{Est. cost (p.a.)} \\
\hline
Infrastructure & Server hosting (PaaS), managed database (MongoDB atlas) & €600 \\
Third-Party APIs & Google Maps API, ZBE data provider, fuel price API & €500 - €1,500 \\
App store fees & Apple developer program, Google Play developer account & €125 \\
Contingency (15\%) & For unforeseen development challenges and scope changes & €3,757 (initial) \\
\hline
\textbf{Total (First year)} & & \textbf{€4,982 - €5,982} \\
\hline
\end{tabular}
\end{table}
